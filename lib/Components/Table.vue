<script>
import { nextTick } from "vue";
import { Splade } from "./../Splade.js";

import debounce from "lodash-es/debounce";
import endsWith from "lodash-es/endsWith";
import filter from "lodash-es/filter";
import forOwn from "lodash-es/forOwn";
import isArray from "lodash-es/isArray";
import isEqual from "lodash-es/isEqual";
import map from "lodash-es/map";
import startsWith from "lodash-es/startsWith";

export default {
    props: {
        striped: {
            type: Boolean,
            required: false,
            default: false
        },

        columns: {
            type: Object,
            required: true
        },

        defaultVisibleToggleableColumns: {
            type: Array,
            required: true
        }
    },

    data() {
        return {
            visibleColumns: [],
            forcedVisibleSearchInputs: []
        };
    },

    computed: {
        /**
         * Returns a boolean whether the currently toggled columns
         * differ from the default set of visible columns.
         */
        columnsAreToggled() {
            return !isEqual(this.visibleColumns, this.defaultVisibleToggleableColumns);
        },

        /*
         * Returns a boolean whether there are Search Inputs visible
         * that are not (yet) in the query string.
         */
        hasForcedVisibleSearchInputs() {
            return this.forcedVisibleSearchInputs.length > 0;
        }
    },

    mounted(){
        const query = this.getCurrentQuery();

        const columns = query.columns || [];

        // Parse the query string and figure out whether there
        // are Search Inputs that should be visible.
        forOwn(query, (value, key) => {
            if(startsWith(key, "filter[") && !value){
                const splittedKey = key.split("[");
                const filterKey = splittedKey[1].substring(0, splittedKey[1].length - 1);

                this.forcedVisibleSearchInputs = [...this.forcedVisibleSearchInputs, filterKey];
            }
        });

        // Set the visible columns.
        if(columns.length === 0) {
            this.visibleColumns = this.defaultVisibleToggleableColumns;
        } else {
            this.visibleColumns = columns;
        }
    },

    methods: {
        /**
         * Resets the table to its initial state.
         */
        reset() {
            this.forcedVisibleSearchInputs = [];
            this.visibleColumns = this.defaultVisibleToggleableColumns;

            let query = this.getCurrentQuery();

            query.columns = [];
            query.page = null;
            query.perPage = null;
            query.sort = null;

            forOwn(query, (queryValue, queryKey) => {
                if(startsWith(queryKey, "filter[")){
                    query[queryKey] = null;
                }
            });

            this.visitWithQueryObject(query, null, true);
        },

        /*
         * Returns a boolean whether the given key is visible.
         */
        columnIsVisible(key){
            return this.visibleColumns.includes(key);
        },

        /*
         * Toggles the column key.
         */
        toggleColumn(key) {
            // Invert the current visibility.
            const show = !this.columnIsVisible(key);

            // Generate a new array with all visible colums.
            const visibleColumns = filter(this.columns, (column) => {
                if(!column.can_be_hidden) {
                    return true;
                }

                if(column.key === key) {
                    return show;
                }

                return this.visibleColumns.includes(column.key);
            });

            let visibleColumnKeys = map(visibleColumns, (column) => {
                return column.key;
            }).sort();

            // When the array doesn't differ from the default, we can use the default
            // instead of passing all visible columns.
            if (isEqual(visibleColumnKeys, this.defaultVisibleToggleableColumns)) {
                visibleColumnKeys = [];
            }

            this.visibleColumns = visibleColumnKeys.length === 0
                ? this.defaultVisibleToggleableColumns
                : visibleColumnKeys;

            this.updateQuery("columns", visibleColumnKeys, null, false);
        },

        /**
         * Removes the key from being forcefully visible, and sets the value to null.
         */
        disableSearchInput(key) {
            this.forcedVisibleSearchInputs = this.forcedVisibleSearchInputs.filter((search) => search != key);

            this.updateQuery(`filter[${key}]`, null);
        },

        /*
         * Forces the given Search Input key to be visible, and focuses the input element.
         */
        showSearchInput(key){
            this.forcedVisibleSearchInputs = [...this.forcedVisibleSearchInputs, key];

            nextTick(() => {
                const $newEl = document.querySelector(`[name="searchInput-${key}"]`);

                $newEl.focus();
            });
        },

        /*
         * Returns a boolean whether the key should be visible.
         */
        isForcedVisible(key){
            return this.forcedVisibleSearchInputs.includes(key);
        },

        /*
         * Debounces the update query with 350ms.
         */
        debounceUpdateQuery: debounce(function(key, value, $el) {
            this.updateQuery(key, value, $el);
        }, 350),

        /*
         * Parses the window's current query as an object.
         */
        getCurrentQuery() {
            const currentQuery = window.location.search;

            if(!currentQuery) {
                return {};
            }

            let query = {};

            // Remove the question mark and split the keys.
            currentQuery.substring(1).split("&").forEach((keyValue) =>{
                const splitted = decodeURIComponent(keyValue).split("=");

                let key = splitted[0];

                if(!endsWith(key, "]")) {
                    // A regular 'key=value' string
                    query[key] = splitted[1];
                    return;
                }

                // A nested key - grab the key and check if it's a numeric key or a string.
                const splittedKey = key.split("[");
                const stringOrNumericEl = splittedKey[1].substring(0, splittedKey[1].length - 1);

                if(parseInt(stringOrNumericEl) == stringOrNumericEl) {
                    // Handle as an array.
                    key = splittedKey[0];

                    if(!isArray(query[key])) {
                        query[key] = [];
                    }

                    query[key].push(splitted[1]);
                } else {
                    // Handle as an object.
                    query[key] = splitted[1];
                }
            });

            return query;
        },

        /*
         * Update the current query
         */
        updateQuery(key, value, $el, reload)  {
            // When reload is false, it only updates the query
            // string, but doesn't perform a new request.
            if(typeof reload === "undefined") {
                reload = true;
            }

            let queryObject = this.getCurrentQuery();
            queryObject[key] = value;

            // Reset the page value when the 'perPage' or filters change.
            if(startsWith(key, "perPage") || startsWith(key, "filter[")){
                delete queryObject["page"];
            }

            this.visitWithQueryObject(queryObject, $el, reload);
        },

        visitWithQueryObject(queryObject, $el, reload){
            // When reload is false, it only updates the query
            // string, but doesn't perform a new request.
            if(typeof reload === "undefined") {
                reload = true;
            }

            let query = {};

            // Regenerate the query string object.
            forOwn(queryObject, (queryValue, queryKey) => {
                if(!isArray(queryValue)) {
                    query[queryKey] = queryValue;
                    return;
                }

                if(queryValue.length === 0) {
                    return;
                }

                queryValue.forEach((arrayValue, arrayKey) => {
                    query[`${queryKey}[${arrayKey}]`] = arrayValue;
                });
            });

            let queryString = "";

            // Build the query string.
            forOwn(query, (value, key) => {
                if(value === null || value === []) {
                    return;
                }

                if(queryString) {
                    queryString += "&";
                }

                queryString += `${key}=${value}`;
            });

            // Prepend the question mark when needed.
            if(queryString) {
                queryString = "?" + queryString;
            }

            // Build the new URL.
            const url = window.location.pathname + queryString;

            if(!reload) {
                // Just replace the URL.
                return Splade.replaceUrlOfCurrentPage(url);
            }

            // Perform the request, and optionally focus on the given element.
            Splade.replace(url).then(() => {
                if(typeof $el !== "undefined" && $el){
                    nextTick(() => {
                        const $newEl = document.querySelector(`[name="${$el.name}"]`);

                        $newEl.focus();
                    });
                }
            });
        }
    },

    render() {
        return this.$slots.default({
            columnIsVisible: this.columnIsVisible,
            columnsAreToggled: this.columnsAreToggled,
            debounceUpdateQuery: this.debounceUpdateQuery,
            disableSearchInput: this.disableSearchInput,
            hasForcedVisibleSearchInputs: this.hasForcedVisibleSearchInputs,
            isForcedVisible: this.isForcedVisible,
            reset: this.reset,
            showSearchInput: this.showSearchInput,
            striped: this.striped,
            toggleColumn: this.toggleColumn,
            updateQuery: this.updateQuery,
            visit: Splade.visit,
        });
    },
};
</script>